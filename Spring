Spring (融合器)
理念: 使现有的技术更加容易使用;本身是一个大杂烩,整合了现有的技术框架;
优点:
    1. Spring是一个开源的免费的框架(容器);
    2. 是一个轻量级的,非入侵式的框架;    (mybatis也是轻量级的)
    3. 控制反转;    IOC
    4. 面向切面编程; AOP
    5. 支持事务处理,支持框架整合处理;
Spring就是一个轻量级的控制反转IOC 和 面向切面编程AOP的框架;

SpringBoot
    1. 快速开发的脚手架
    2. 基于Spring可以快速开发单个微服务;
    3. 约定大于配置;
SpringCloud
    1. SpringCloud是基于SpringBoot实现的;
=====================================================================================

IOC 控制反转 -> 反转的是什么? -> 控制权由我们 转向 用户;
核心:
    1. 之前是由程序员主动创建对象,控制权在程序员手中;
    2. 使用了set注入后,程序不再具有主动性,而是变成了被动的接收对象;
    本质上解决了问题,我们不再去管理对象的创建了;
        private UserDao userDao;
        // 使用set进行动态实现 值的传入
        public void setUserDao(UserDao userDao){
            this.userDao = userDao;
        }
    效果: 不管用户想使用哪一个Dao 比如MySqlDao,OracleDao,只需要set传入即可一键变化;
          系统的耦合度大大降低,更加注重在业务的实现上.
    总结:
        控制反转是一种通过描述(xml或者注解) 并通过第三方去生产或获取特定对象的方式,在Spring中实现
        控制反转的是IOC容器,其实现方法是DI依赖注入;

Spring入门案例,将对象交给Spring去创建
    // 获取Spring的上下文对象
    ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
    // 我们的对象都是在Spring中管理.我们使用的时候直接取出来即可
    Hello hello = (Hello) context.getBean("hello");
    System.out.println(hello.toString());

    控制 --> 传统的应用程序对象是我们自己new出来的,使用Spring之后,对象是由Spring去创建的;
    反转 --> 程序本身不创建对象,而是被动的接收对象;
    依赖注入 --> 就是使用set方法进行注入的;

    总结:
        我们已经可以不用在程序中改动了,要实现不同的操作,只需要在xml配置文件中进行修改即可;
        所谓的IOC -> 对象由Spring来创建 管理 装配;

IOC创建对象的方式
    1. 使用无参构造方法创建对象
    2. 使用有参构造方法创建对象 -> 下标索引
        在bean标签中 需要这样配置  index代表参数索引 value代表基本数据类型的赋值
        <bean class="com.yqx.pojo.User" id="user">
            <constructor-arg index="0" value="我也不知道"/>
        </bean>
    3. 使用有参构造方法创建对象 -> 通过参数类型
        不建议使用 -> 如果参数全部是String类型 该如何是好?
        <bean class="com.yqx.pojo.User" id="user">
            <constructor-arg type="java.lang.String" value="String类型" />
        </bean>
    4. 使用有参构造方法创建对象 -> 直接通过参数名来设置
        <bean class="com.yqx.pojo.User" id="user">
            <constructor-arg name="name" value="通过name方式传入" />
        </bean>
    Spring容器 程序运行时,bean文件中所有配置的对象都会被创建;
    在配置文件加载的时候,容器中管理的对象就已经初始化了!
========================================================================================

Spring配置
    1. 别名 alias
        <!-- 如果增加了别名,我们可以使用别名获取到这个对象 -->
        <alias name="user" alias="userAlias"/>
    2. bean
        id    ->  bean的唯一标识符,也就是变量名;
        class ->  bean对象所对应的全限定名 : 包名+类名
        name  ->  也是别名,而且name可以取多个别名
            name="u1 u2,u3;u4"  ->  四个别名 都可以取到
    3. import
        一般用于团队开发使用,可以将多个配置文件导入合并成为一个;
        在主配置文件中
            <import resource="bean.xml" /> 即可引入

=========================================================================================

DI 依赖注入
    一. 构造器注入
    二. set方式注入[重点] -> 基本数据类型和引用数据类型改如何注入
        依赖: Bean对象的创建依赖于Spring容器
        注入: Bean对象中的所有属性,都由容器来注入
                详情见 --> applicationContext.xml
    三. 其他(第三方)方式
        使用方式: 在xml中导入标签依赖,然后直接就可以使用了
            <bean id="user" class="com.yqx.User" p:name="张三" p:age=18>
         p -> 命名空间; xmlns:p="http://www.springframework.org/schema/p"
         c -> 命名空间; xmlns:c="http://www.springframework.org/schema/c"

=========================================================================================

Bean Scope Bean的作用域
    The Singleton Scope 单例模式 -> 创建Bean时,scope默认都是单例;
        无论由多少个DAO,获取到的Bean对象都是同一个;也就是Bean对象只存在一个;

    The Prototype Scope 原型模式
        每次从容器中get的时候,(每次创建)获取到的Bean都是一个单独的对象;

    Request:
        对象在一次请求中创建,请求过后对象消失;
    Session:
        对象一直在Session中也就是浏览器中活着;
    Application:
        全局;

=========================================================================================

















